\section{Communication and Intermediate Code}
\label{sec:Communications_and_Intermediate_Code}


\subsection{Communication Model}
\label{sec:Communication_Model}


\subsection{Intermediate Code}
\label{sec:Intermediate_Code}

As XML-based approach was discarded, a new language was to be designed in order to express the information extracted from the source code interpretation and pass it to a new ad-hoc interpreter. This interpreter will parse these instructions (m-code sentences) and give the "script" of the animation or "play" to the Director, which displays the actors on the screen. These cinematographic metaphors come from the previous versions of Jeliot. Director stands for the component that manages the different pieces of information (actors) on the screen.

The m-code syntax is quite simple. While the inner representations of the m-code commands are numbers, Java constants are used to refer to them. The usual m-code sentence will consist of:

\begin{itemize}
\item {\bf{Expression/Statement code}}: A shortcut for every Java statement or expression is used: e.g. AE stands for Add Expression. The chosen names are heavily related to the ones used in DynamicJava.
\item {\bf{Reference:}} Every Expression/Statement sentence is identified by a number. This way nested statements and expressions can be formed up from previous m-code sentences.
\item {\bf{Related References:}} Most of the m-code sentences refer to previous m-code sentences. One Add Expression will refer to the references of both sides of expression. Flow-control statements will refer to a condition expression, and so on.
\item {\bf{Value:}} Most sentences will return the value resulting from the executing of an expression. If it is a flow control statement it will return a Boolean value indicating the result of the condition.
\item {\bf{Type:}} Every expression that has a result must specify its type.
\item {\bf{Location:}} This contains the location of the expression in the original source code file.
\end{itemize}

Some auxiliary m-code commands have been defined to simplify m-code interpretation, especially when referring to assignments and binary expression:

\begin{itemize}
\item {\bf{BEGIN:}} Indicates beginning of an assignment or expression. It encapsulates nested expressions, literals or qualified names.
\item {\bf{LEFT:}} Indicates beginning of the left hand side of an expression.
\item {\bf{RIGHT:}} Indicates beginning of the right hand side of an expression.
\item {\bf{TO:}} Indicates the beginning of the assignment destination.
\item {\bf{END:}}  States the end of the current program execution.
\end{itemize}

One typical assignment like a = b + 1; is coded as follows:

Begin|Assignment|1|1,1,1,10\\
Begin|AddExpression|2|1,5,1,10\\
Left|3\\
QualifiedName|3|b|1|int\\
Right|4\\
Literal|4|1|int|1,9,1,10\\
AddExpression|2|3|4|2|int|1,1,1,10\\
To|5\\
QualifiedName|5|a|UnknownValue|int\\
Assignment|1|2|5|2|int|1,1,1,10

In this example we find two new commands QUALIFIED NAME and LITERAL. QUALIFIED NAME refers to variables previously declared and LITERAL states for literal values, as numbers, characters or strings.

For a complete listing of commands and their descriptions see the Intermediate Language Specifications document..


\subsubsection{Evaluation Visitor}
As commented previously EvaluationVisitor was the main class to be modified. In the next subsections I will describe how M-code is produced for certain subsets of Java expressions and statements:

{\bf{Static Method Call}}

Static method call is the entry point to the evaluation visitor. It is the visitor called when invoking the main method of a class.
The first the I/O management is done. I/O facilities were to be built-in in DynamicJava, as they require special treatment in the Jeliot side. We have chosen to keep on using the I/O library provided by Jeliot 2000, nevertheless this can be changed by doing some simple changes in EvaluationVisitor. When visiting a static method call [public Object visit(StaticMethodCall node)], we first ask for the declaring class.

\begin{itemize}
\item If it is an Input class we ask the Director to provide the information requested by ways of one pipe that communicate both sides. We discriminate the type by the method name. Every input method has an equivalent in ECodeUtilities, where the value is actually read from the pipe. An m-code command named INPUT has been defined to request data of a given type from the director.
\item If it is an Output class then the only method currently available is println. DynamicJava visits the argument and sends the resulting string to the Director with the command OUTPUT.
\end{itemize}

After that a stack is maintained by StaticMethodCall and Return visitors to manage multiple method calls (E.g. return object.method()). A reference number is pushed into the stack in every method call.

Later, the argument types are processed and m-code is produced to inform m-code interpreter which the types are. Finally DynamicJava will invoke the method with all the information. When the invocation ends a special statement is produced to indicate the end of static method call (SMCC).

However, when a static method call refers to a foreign method (no source code is provided for it), the normal invocation will only return the value, if it is not a void method. But to visualize the call properly we need to simulate the parameters passing and the method declaration m-code statements. Moreover, the value returned must be inside a return m-code statement, again for visualization purposes, so it is simulated too.

{\bf{Return Statement}}

A return statement can contain a value to return or nothing at all (a void method or function). If there is something to be returned a BEGIN statement is produced before visiting the expression to be returned. Otherwise a simple return statement is produced with the special constant Code.NO\_REFERENCE, so jeliot interpreter will not look for an expression.

A stack is maintained by StaticMethodCall and Return visitors to manage recursive method calls (E.g. return object.method()). A reference number is pushed into the stack in every method call. The return statement will pick it up from the top of the stack and that will identify the return statement.

{\bf{Simple Assign Expression}}

A BEGIN statement is produced indicating the beginning of a new assignment. Then the right expression is visited and thus it produces its own m-code. A special statement TO is produced pointing the beginning of the left expression, where the value obtained interpreting the right expression will be stored. This left expression was not visited in the original DynamicJava, as it is not needed to modify the context. However we need to visualize that expression, so an "artificial" visit was added. An evaluating flag is set to show that it is an "artificial" visit. Finally we produce the assign code with references to both expressions.

{\bf{Qualified Name}}

Qualified Names are the names already declared (e.g. variable names and any other identifier) and they are used in expressions. Its visitor was modified to take into account the evaluating flag. The reason of having two different behaviours is that DynamicJava throws an ExecutionError when visiting an uninitialized qualified name. That occurs an artificial visit is made in assignments. So when the evaluating flag is false the DynamicJava invokes display method to avoid unnecessary exceptions.  However, both methods (visit and display) produce the same m-code.

{\bf{Variable Declaration}}

Variable declaration does not cause big modifications to original source code. Only if an initialization expression is found we have to modify the normal process to visualize the initialization. This is done by simulating an assignment after the variable is declared.

{\bf{Flow Control Statements}}

All flow control statements work similarly. Here, I will explain how a while statement produces its m-code. Other statements work in a similar way.

Firsts of all, the while statement node keeps the reference to the condition that will be visited and will determine whether to enter or not the body of the statement. If the condition holds the visitor produces a WHILE statement with TRUE as a value. Then the body is evaluated, producing its own m-code.

Break or continue visitors throw exceptions to be caught by the flow control statements. When they are caught their corresponding m-code statement is produced. This statement reflects where the break or continue has happened (WHILE, FOR, DO and SWITCH expression)

{\bf{Boolean and Bitwise Unary Expressions}}

This group contains the not (!) and complement (~) operators. There are two different possibilities. On the one hand the expression can be constant and not evaluation is performed by DynamicJava, and the generation of m-code is straightforward. However, as there is no expression to be referred, only a value is returned. Code.NO\_REFERENCE is used to indicate this fact to the interpreter. On the other hand, when there is an expression to negate, a BEGIN statement is produced before the expression to be negated is visited. Finally the unary statement is produced returning the value and referring to the expression it affects.

{\bf{Unary arithmetic expressions}}

This group contains increments and decrements (++, --). No special modifications were carried out in these visitors. They just generate a BEGIN statement and their own statement (PIE, PDE, PRIE,PRDE), that returns the modified value and the type.

{\bf{Binary Expressions}}

This group comprises all boolean, bitwise and arithmetic binary operators. As usual, a BEGIN statement is produced, anticipating what the operator is. Then both sides of the expression are visited and their values are collected. Before each of these two visits there is one special m-code statement: a LEFT statement, for the left side, and a RIGHT statement for the right side. Finally the binary statement is generated referring both sides and the value resulting of applying the operator to both sides of the expression.

{\bf{Compound Assignment Expressions}}

This group contains all bitwise and arithmetic compound assignments. Compound operators are for example +=, *=, /= and >=. The visitors of these compound assignments have been modified to produce m-code that decomposes the compound assignment into a simple assignment and a binary operation. E.g. a+=3-b will be interpreted as a=a+(3-b).

Then, the code of the visitors is just a composition of an assignment and a binary expression as its right hand side. This binary expression has as its sides the same ones that the compound assignment. As a result of these two fake or artificial visits are done to the left hand side of the compound assignment.

\subsubsection{Tree Interpreter}

This class contains methods to interpret the constructs of the language. This class is the one called from Jeliot to start interpreting a program or a single method. There are two main methods that have been modified.

{\bf{interpret(Reader r, String fname)}}

This method receives the source code and invokes the three visitors DynamicJava consists of: NameVisitor, TypeCheker and EvaluationVisitor. This method catches the execution and parsing errors and generates m-code to notify Jeliot of the possible lexical, syntax or semantic errors that are found during the interpretation.

{\bf{interpretMethod(Class c, MethodDescriptor md, Object obj, Object[] params)}}

Whenever a domestic method is invoked by the interpreter, this method will construct everything that allows interpreting it. The m-code generated by this method provides the names of the formal parameters so they are added to the method variables by the Jeliot interpreter. It also indicates the location of the method declaration in the source code by means of a special m-code statement: MD, method declaration. All these are the information that are generated in StaticMethodCall if the method is a foreign one. The flag inside is set to indicate that the currently interpreted method is a domestic method.
