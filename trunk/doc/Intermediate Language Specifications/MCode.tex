\chapter{MCode Language}
\label{ch:MCode}

\section{Introduction}
\label{sec:Introduction}

\mcode{} is defined to be an interpreted line by line and each line can be divided in the smaller pieces or tokens. Here we define all the commands that are part of \mcode{}.
First of all, we will introduce the notation used in this specification. as it is not standard. In our notation each token is now separated by single '§' character, this token will not be shown hereinstead a blank space will be used to help readability. Each token is first introduced as an English name. Later a sample instruction is given, consisting of the different tokens that build that particular instruction. If the token is in big letters it is a preserved word. If it is in small letters it will be replaced by variable value or integer.
Table ~\ref{tab:token_abbreviations} shows the abbreviations used in the specification to refer to some common tokens:

\begin{table}[htbp] 
\begin{tabular}{|p{7em}|c|p{18em}|}
\hline
Name & Abbreviation & Meaning \\\hline 
Instruction Reference & ir & Used to keep track of instructions used in the past.\\\hline 
Left Instruction Reference & lir & A reference to a previous instruction used as the left operand.\\\hline 
Right Instruction Reference & rir & A reference to a previous instruction used as the right operand. \\\hline 
Instruction Counter & ic & Counter of expressions, making instructions unique and easily referenciable \\\hline 
Type of instruction & ti & Refer to some m-code instruction (e.g. ADD)\\\hline 
Location & lo & Variable that holds the location of the expression in the source code, defined by "`beginning of line"', "`beginning of column"', "`end of line"', "`end of column"'\\\hline 
\end{tabular}
\caption{Token Abbreviations.} 
\label{tab:token_abbreviations} 
\end{table}

The usual \mcode{} sentence will consist of:

\begin{description}

	\item{Expression/Statement code} A shortcut for every Java statement or expression is used: e.g. AE stands for Add Expression. The chosen names are heavily related to the ones used in \djava{}.
	
	\item{Reference} Every Expression/Statement sentence is identified by a number. This way nested statements and expressions can be formed up from previous m-code sentences.
	
	\item{Related References} Most of the m-code sentences refer to previous m-code sentences. One Add Expression will refer to the references of both sides of expression. Flow-control statements will refer to a condition expression, and so on.
	
	\item{Value} Most sentences will return the value resulting from the executing of an expression. If it is a flow control statement it will return a Boolean value indicating the result of the condition.
	
	\item{Type} Every expression that has a result must specify its type.
	
	\item{Location} This contains the location of the expression in the original source code file.
	
\end{description}

\section{Grammar}

%\begin{mcodegrammar}

Program: StaticMethodCall .
Declaration: MD ; CD .

%\end{mcodegrammar}

\section{Constants}
\label{sec:constans}

Table~\ref{tab:constants} contains the constants used in the implementation of \mcode{} to support portability and maintainability.

\begin{table}[htbp] 
\begin{tabular}{|p{7em}|p{25em}|}
\hline Constant & Meaning \\\hline 
DELIM & Used to separate tokens on a single instruction. They have to be explicitly added to the m-code instruction\\\hline 
LOC DELIM & Used to separate the different coordinates that locate some source code.\\\hline 
UNKNOWN & When some variable value cannot be accessed it is given an UNKNOWN value.\\\hline 
NO REFERENCE & ??\\\hline 
REFERENCE & ??\\\hline 
NOT FINAL & ??\\\hline 
FINAL & ??\\\hline 
TRUE & String that represent the TRUE Boolean value in the working environment.\\\hline 
FALSE & String that represent the FALSE Boolean value in the working environment.\\\hline 
\end{tabular}
\caption{Constants.} 
\label{tab:constants} 
\end{table}

\section{Auxiliary Instructions}
\label{sec:auxiliary}

Some auxiliary instructions are defined in order to ease the interpretation of the m-code. These instructions are not related to any particular Java construct and are used by those that need them.

\subsection{BEGIN}

\minstr{BEGIN ti ir loc}

Instruction used to mark the beginning of those instructions that admit instructions to be encapsulated within them. Those instructions are Assignment, Return, Parameter, Array Access and all unary and binary operations; and they are referred through it. The referred instructions get they ir assigned in the BEGIN instruction.

\subsection {LEFT and RIGHT}

\minstr{LEFT/RIGHT ir}

These instructions are similar to BEGIN. Both of them are used to mark the beginning of the left/right side of a binary operation. The ir obeys the same reason than in BEGIN, "`reserves"' the reference number for the following instruction.

\subsection {TO}

\minstr{TO ir}

This instruction is used in assignments and reflects the movement of the value to the left hand side of the assignment. ir points to the qualified name that will hold the value. As said before, this instruction is used in assignment and more concretely in Assignment, Variable Declaration (those with initializer) and Compound Assignment.

\subsection {ERROR}

\minstr{ERROR errorMessage loc}

Parser and execution errors are reported to the visualization engine with the ERROR instruction. errorMessage is a string that can contain HML and it is what will be visualized.

\subsection {END}

\minstr{END}

END is produced at the end of the m-code program and indicates the visualization to terminate. 

\subsection {SCOPE}

\minstr{SCOPE 1/0}

New blocks of Java code are delimited in m-code through SCOPE. This instruction second token indicates whether it is opening a new one (1) or closing one (0).

\subsection {CONSCN (Constructor Call Number)}

\minstr{CONSCN ir}

This instruction is created because in \djava{} the super method calls in the beginning of the constructor
are handled before the actual constructor invocation and thus the information is not extracted in the correct order. The constructor call number is used to correct the order so that during the simple allocation visit in EvaluationVisitor the constructor call number is send for the first time. When all the super method calls are finished and the constructor is really invoked the constructor call number is printed out again. The \mcode{} interpreter collects all the commands between the corresponding constructor call numbers and executes them after the constructor is really invoked that is two lines after the second constructor call number is read.

\section{Statements}

\subsection{A (Assignment)}

\minstr{A ir rir lir value type loc}

The assignment instruction is composed by its own reference (ir) and the references to the left and right hand sides (lir, rir). Furthermore it contains the assigned value and its type.

It is worth to mention that compound assignments are decomposed into the operation and a simple assignment.

\subsection{VD (Variable Declaration)}

\minstr{VD name NO\_REFERENCE value type FINAL/NOT\_FINAL loc}

When declaring a variable the corresponding the m-code instruction needs to be complemented with its name, value, type and the modifier (FINAL or NOT\_FINAL). NO\_REFENRENCE

\section{Binary Operations}

\minstr{binaryCode ir rir lir value type loc}

Binary instructions are composed by its bynaryCode,its own reference (ir) and the references to the left and right sides of the expression(lir, rir). Furthermore it contains the assigned value and its type.
Binary codes can take any of the following values:

\begin{table}[htbp]
	\centering
		\begin{tabular}{|p{6em}|c||p{6em}|c||p{6em}|c|}
		\hline
		Boolean Operators & \mcode{}    & Arithmetic operators & \mcode{}    & Bitwise operators & \mcode{}\\\hline\hline
		AND \&\&          & \p{AND}     & ADD +                & \p{AE}      & AND \&            & \p{BITAND}\\\hline
		OR $\|$           & \p{OR}      & SUBTRACT \-          & \p{SE}      & OR $\|$           & \p{BITOR}\\\hline
		XOR \^{\ }        & \p{XOR}     & MULTIPLY *           & \p{ME}      & XOR \^{\ }        & \p{BITXOR}\\\hline
		LESSER THAN <     & \p{LE}      & DIVIDE  /            & \p{DE}      & LEFT SHIFT <<     & \p{LSHIFT}\\\hline
		GREATER THAN >    & \p{GT}      & REMAINDER \%         & \p{RE}      & RIGHT SHIFT >>    & \p{RSHIFT}\\\hline
		EQUAL ==          & \p{EE}      &                      &             & UNSIGNED SHIFT >>> & \p{USHIFT}\\\hline
		NOT EQUAL !=      & \p{NE}      & & & &\\\hline
		LESSER OR EQUAL THAN >= & \p{LQE} & & & & \\\hline
		GREATER OR EQUAL THAN =< & \p{GQT} & & & & \\\hline
		\end{tabular}
	\caption{Binary Operators}
	\label{tab:BinaryOperators}
\end{table}

\section{Unary Operations}

\minstr{unaryCode ir reference value type loc}

As with binary operatoions the unary instructions take the same tokens. The only difference is that there is only one reference to another instruction. value, type and loc maintain the same meaning. As before there are several Java unary operators, all of them are listed in the following table:

\begin{table}[htbp]
	\centering
		\begin{tabular}{|p{6em}|c||p{6em}|c||p{6em}|c|}
		\hline
		Boolean Operators & \mcode{}    & Arithmetic operators & \mcode{}    & Bitwise operators & \mcode{}\\\hline\hline
		NOT !& NO & POST\-IN\-CRE\-MENT ++ & PIE & COM\-PLE\-MENT \~{ } &  COMP \\\hline
& & POST\-DE\-CRE\-MENT -- & PDE  & & \\\hline
& & PRE\-IN\-CRE\-MENT ++ & PRIE  & & \\\hline
& & PRE\-DE\-CRE\-MENT -- & PRDE & & \\\hline
& & PLUS + & PLUS & & \\\hline
& & MINUS - & MINUS & & \\\hline
	\end{tabular}
	\caption{Unary Operators}
	\label{tab:UnaryOperators}
\end{table}

\section{Literal constant and variable access}

\subsection{Qualified Name}

\minstr {QN ir name value type}

Qualified names are those local variables to the method or block. mcode{} instruction contains the reference (ir) of the instruction and the name value and type of the qualified name. If the variable is not initialized value will be UNKNOWN.

\subsection{Literal}

\minstr{L ir value type loc}

Literals are the constants values in the source code( e.g. 3 is one integer literal and "`3"' is one string literal). The m-code instruction contains all the information needed for the visualization as well as its reference (ir): value, type and loc. 

\section{Control Structures}

\subsection{If Statements}

\minstr{IFT/IFTE condition value loc}

There are two possible instructions for an "`If"' statement. IFT if there is not else statement or IFTE if there is. The composition, however, is similar. condition is the reference to the instruction that evaluate the condition. value holds the result of the evaluated condition and will tell which branch execution is following. loc as usual contains the code location.

\subsection{While For and Do-While Statements}

\minstr{WHI/FOR/DO condition value round loc}

These statements produce a similar to the previous one. They only differ in the round token. This token holds the number of iterations the while loop has made.

\subsection{Switch}

Three m-code instructions are related to the switch statement\par

\minstr{SWIBF selector ir loc}

NIKO

\minstr{SWITCH loc}

NIKO

\minstr{SWITCHB loc}

NIKO

\subsection{Break and Continue}

\minstr{BR/CONT statement loc}

Break and continue asserts instructions only specify which statement they are  in. Allowed values for statement are WHI FOR IFT IFTE SWITCH, those were you can find these statements.

\section{Input and Output}

\subsection{Input}

\minstr{INPUT ir type loc}

The INPUT instruction indicates the visualization engine to produce some data of the type specified and return it to Java interpreter. This data will be written in a dedicated pipe that connects both sides. The next instruccion indicates the obtained value from the pipe.

\minstr{INPUTTED counter value type loc}

\subsection{Output}

\minstr{OUTPUT ir value type loc}

OUTPUT instruction is the resulting one of a call to any of the Output methods provided by jeliot. They only accept one argument, and it is reflected in the instruction by its value and its type.

\section{Array Handling}

\subsection{Array Allocation}

\minstr{e dimension dimensionsReferences dimensionsSizes loc}

Array allocation instruction is a complicated one, as it carries a lot of information about the array. As usual a ir is provided. Following the arrayHashCode of the object created to allocate it. It can be any other number that identify one-to-one the allocated object on the interpretation. type contains the type of the array components. dimensionReferences is a comma separated list with the references to the instructions that evaluated the sizes' expressions of the array. Finally dimensionsSize is another comma separated list where each element is the size of a dimension. new Integer[4][5] will produce AA ir 456744 Integer 2 ir1,ir2 4,5 loc. Where ir1 and ir5 must be references to the literal instructions of "4" and "5".

\subsection{Array Access}

\minstr{AAC ir arrayNameReference deep cellReferences cellNumbers value type loc}

Array accesses instructions consist on different tokens. The common ones (ir, value, type and loc) are also present. But we can find very specific ones. arrayReference points to the instruction produced when visiting an array name, normally a qualified name. deep refers to the level of deepness of the array access. This is useful for multidimensional arrays when they are not accessed till the last level, the one holding the data value. cellReferences and cellNumber meet the same purpose than dimensionReferences and dimensionsSizes in array allocation (AA) instruction. cellReferences points to the instructions that evaluated the value of each cell pointer. cellNumbers are the actual values of the cell access. Both of them are presented as a comma separated list. For example in array[3][5], cellReferences will point to the literal instruction of "`3"' and "`5"' and cellNumbers will contain "`3, 5"'.

\subsection{Array Length}

\minstr{AL objectCounter "length" value type loc}

\section{Object Oriented}

This section contains the instruction related to object oriented. Here we will just summarize its properties and main arguments. However following chapters will explain you how to glue the different instructions together to form meaningful \mcode{} programs.

\subsection{Parameters}

\minstr{PARAMETERS parameterArray}

The PARAMETERS instruction will provide the visualization engine a list of the types of the parameters used in the method declaration.

\minstr{P ir loc}

This instruction declares a new parameters in a method call.

\subsection{Method Declaration}

\minstr{MD ir loc}	

A method declaration instruction will indicate the location of the called method code and the beginning of its evaluation.

\subsection{Static Method Call}

\minstr{SMC name declaringClassName numArgs loc}

The SMC instruction consists of the actual name of the method, its declaring class name and the number of arguments this method call consists of.

\minstr{SMCC}

This instruction indicates the end of a call to a static method.

\subsection{Object Method Call}

\minstr{OMC name numArgs objectReference loc}

The OMC instruction is similar to the static method one. However it contains a reference to an object, this reference points to the instruction that holds the variable access to the object that is making the method call.

\minstr{OMCC}

As before it just closes the object method call.

\subsection{Class Allocation}

\minstr{SA ir declaringClass constructorName numArgs loc}

The class allocation instruction happens everytime a \p{new} appears on the source code. It will provide the information needed for the constructor: declaring class, constructor name and the number of arguments it is being called with.

\minstr{SAC ir ObjectId loc}

\subsection{Object Field Access}

\minstr{OFA ir objectReference name value type loc}

This instruction accesses to the value of an object field, thus it references to the instruction that evaluate the object (objectReference) (normaly a Qualified Name (\p{QN} one). It contains the name, the type and the value of the accessed field.

\subsection{Return}

\minstr{R callIr loc}

This first return instruction is just used for the "void" return, those that doesn't return anything.NIKO what 
do we say about the callIr.

\minstr{R callIr valueIr value type loc}

This second instruction is used whe a value is returned. Thus we need a reference to the evaluation of the expression corresponding to the returned value (valueIr) and the result of this expression, its value and type.