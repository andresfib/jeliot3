#summary MCode Speficication main page. Describes the basic stuff.
#labels mcode,Jeliot-C

= Introduction =

This document is to describe the M code language and its functions; this document goes together with the MCode Language in explanation in which Andrés Moreno García documented for his thesis. 
 
Here are a few examples of the Mcode that is generated by the compiler for the use of the visualisation tool.

First of all we will look at some basic programming statements and see the output from them after that we aim to look at how we believe the compiler for the C version should output M Code and the new instructions that we believe are required for that to happen. 

Note the separator for this in the MCode language is § this has been left out so that it is easier to read the statements, at the end of the document you will find all examples in there true form. 



= Details =

1. int x;

26	x	0	?	int	1	6,9,6,17

26 is the number given to the instruction of VD, an index of which can be found at the end of this document. 


VD (Variable Declaration) is described as 

VD name NO_REFERENCE/ir value type FINAL/NOT_FINAL
Loc

When declaring a variable the corresponding the MCode instruction needs to be omplemented with its name, value, type and the modifier (FINAL or NOT_FINAL).  Instruction reference (ir) is given if the variable has an initializer otherwise a NO_REFERENCE value is written.

This can be seen form the values found up above.

26 is the reference for VD as found in the reference table. 

X is the name of the variable

0 is the instruction reference, in this case 0 the first instruction

? is the value of the variable which if not know will be ? 

int is the type of the variable others can be double, char etc

1 means that the value of the variable is not final and can be altered latter on in the program 

6,9,6,17 is the location of the variable. 


2. x = 3;

After setting up the variable we can begin to use the variable 
The MCode from the program 
3	5	2	8,5,8,9		
4	3				
27	3	V	?	int	0,0,0,0
28	4	3	Int	8,9,8,9	
5	24	3	3	int	8,5,8,9


Translated

Begin 	A	2	8,5,8,9
	To	3
	QN	3	v	?	int	0,0,0,0
L	4	3	int	8,9,8,9
A	2	4	3	3	int	8,5,8,9


The instructions are described as follows with the values shown 

BEGIN ti ir loc 

Instruction used to mark the beginning of those instructions that admit instructions to be encapsulated within them. Those instructions are Assignment, Return, Parameter, Array Access and all unary and binary operations; and they are referred through it. This is represented by the type of instruction (ti) The referred instructions get they ir assigned in the BEGIN instruction.  

What we have here is an assignment operator classed as A 

3 is the begin operator 

5 is the A (Assignment operator)
2 is the instruction reference (ir)
6,9,6,17 is the location of the expression in the source code. 

TO ir
This instruction is used in assignments and reflects the movement of the value to the left hand side of the assignment. The ir points to the qualified name that will hold the value. As said before, this instruction is used in assignment and more concretely in Assignment, Variable Declaration (those with initializer) and Compound Assignment.

4  is the To operator
3 is the instruction reference from which it is related to. 



QN ir name value type loc
Qualified names are all the local variables. MCode instruction contains the reference (ir) of the instruction and the name value and type of the qualified name. If the variable is not initialized value will be UNKNOWN.

27 is Qualified Name (QN)
3 is the ir
V is the variable name
? the value is unknown at the moment
Int is the type 
0,0,0,0 is the location

L ir value type loc

Literals are the constants values in the source code (e.g. 3 is one integer literal and “3” is one string literal). The MCode instruction contains all the information needed for the visualization as well as its reference (ir), value, type and loc. 

28 is L (Literal)
4 is the ir
3 is the value
Int is the type
8,9,8,9 is the location


A ir rir lir value type loc
The assignment instruction is composed by its own reference (ir) and the references to the left and right hand sides (lir, rir). Furthermore it contains the assigned value and its type. It is worth to mention that compound assignments are decomposed into the operation and a simple assignment.

5 is A (from table)
2 is the ir
4 is the right instruction reference (rir)
3 is the left instruction referenct (lir)
3 is the value 
Int is the type
8,5,8,9 is the location


3.   
    int x = 0;
    int i = 0;
    
    while (i <2){
   	x = i;
   	i++;
    }


The declaration of the two variables is the same as they where shown up above in example 1 and 2, the steps are combined to assign 0 to each variable. 

For the while statement, the following sample of the M Code is generated. 

3	22	8	8,12,8,15			
1	9					
27	9	i	0	int	0,0,0,0	
2	10					
28	10	2	Int	8,15,8,15		
22	8	9	10	TRUE	boolean	8,12,8,15
40	8	TRUE	0	8,17,11,9		
35	1					
3	5	11	9,12,9,16			
4	12					
27	12	x	0	int	0,0,0,0	
27	13	i	0	int	0,0,0,0	
5	11	13	12	0	int	9,12,9,16
3	13	14	10,12,10,14		
2	15					
27	15	i	0	int	0,0,0,0	
13	14	15	1	int	10,12,10,14
35	0					

This then translate to the following using the table in the reference. 

Begin	LE	8	8,12,8,15
Left	9
QN	9	i	0	int	0,0,0,0
Right	10
L	10	2	int	8,15,8,15
LE	8	9	10	TRUE	Boolean	8,12,8,15
WHI	8	TRUE	0	8,17,11,9
SCOPE	1
Begin A	11	9,12,9,16
To	12
QN	12	x	0	int	0,0,0,0
QN	13	i	0	int	0,0,0,0
A	11	13	12	0	int	9,12,9,16
Begin	Pie	14	10,12,10,14
Right	15
QN	15	I	0	int	0,0,0,0
Pie	14	15	1	int	10,12,10,14
Scope 0
 

LEFT/RIGHT ir
These instructions are similar to BEGIN. Both of them are used to mark the beginning of the left/right side of a binary operation. The ir obeys the same reason than in BEGIN, “reserves” the reference number for the following instruction.

1	9

1 is the number given to the instruction set Left
9 is the ir


binaryCode ir rir lir value type loc

Binary instructions are composed by its binaryCode, its own reference (ir) and the references to the left and right sides of the expression (lir, rir). Furthermore, it contains the assigned value and its type. The binaryCode can take any of the values shown in Table A.3
 

22	8	9	10	TRUE	Boolean	8,12,8,15

22 is the Less than operator. 
8 is the ir
9 is the lir
10 is the rir
TRUE is the value of the operation
Boolean is the type of answer the valus is 
8,12,8,15 is the location
 
WHI/FOR/DO condition value round loc
These statements produce a similar to the previous one. They only differ in the round
token. This token holds the number of iterations the loop has made.

40	8	TRUE	0	8,17,11,9

40 is the while number on the reference
8 is the condition
TRUE is the value
0 is the round 
8,17,11,9 is the location


SCOPE 1/0
New blocks of Java code are delimited in MCode through SCOPE. This instruction second token indicates whether it is opening a new one (1) or closing one (0).

35  1

35 is the Scope number

1 indicates that the scope is a new block of code. 


unaryCode ir reference value type loc

As with binary operations the unary instructions (unaryCode) take the similar tokens. The only difference is that there is only one reference to another instruction. The value, type and loc maintain the same meaning. As before there are several unary operators that can be assigned to the unaryCode, all of them are listed in Table A.4.
 

13	14	15	1	int	10,12,10,14

13 is the PIE reference number
14 is the ir 
15 is the reference 
1 is the new value of the variable
Int is the type of variable
10,12,10,14 is the location


These instructions continue until the condition is not meet i.e the LE comes back as False and the WHI instruction stops going into the loop.
  
4. 

int x = 0;
    	int i = 5;
    
    	if (i < 3){
       		x = 10;
  	  }
  	  else {
    		x = 2;
   	 }

The beginning of this instruction is the same as the other 3 examples above. 

The code above is very similar to that of the while statement in that the M code generated is the same except instead of the Whi command we get an IFTE command 


The values of the M Code are displayed below

3	22	8	8,9,8,13				
1	9						
27	9	i	5	int	0,0,0,0		
2	10						
28	10	3	int	8,13,8,13			
22	8	9	10	FALSE	boolean	8,9,8,13	
34	8	FALSE	11,10,13,5			
35	1						
3	5	11	12,9,12,13			
4	12						
27	12	x	0	int	0,0,0,0		
28	13	2	int	12,13,12,13		
5	11	13	12	2	int	12,9,12,13
35	0						



BEGIN	LE	8	8,9,8,13			
	LEFT 	9				
	QN	9	i	5	int	0,0,0,0
	RIGHT	10				
	L	10	3	int	8,13,8,13	
LE	8	9	10	FALSE	boolean	8,9,8,13
IFTE	8	FALSE	11,10,13,5		
SCOPE	1					
BEGIN	A	11	12,9,12,13		
	TO	12				
	QN	12	x	0	int	0,0,0,0
	L	13	2	int	12,13,12,13
A	11	13	12	2	int	12,9,12,13




The IFTE command is described as follows

IFT/IFTE condition value loc
There are two possible instructions for an “If” statement. IFT is printed if there is not an else statement or IFTE if there is an else statement. The composition, however, is similar. The condition is the reference to the instruction that evaluate the condition. The value holds the result of the evaluated condition and will tell which branch execution is following. The loc as usual contains the code location.

If the value is true it will go into the first scope other wise it will go into the second scope. In this case the value returned is false and therefore the command will go into the second scope. 
 
In this section we will look at how the C language will change the different instructions in the MCode language by adding certain information into the instruction. These differences will be detailed below. 

Please note that these examples where done out by hand and not through the use of a MCode compiler. 

1.

int *ptr;
int x = 3;
ptr = &x;

Since the MCode will be representing the C language, which includes pointers (a * before the name of the variable and after the type of variable) and pointers to pointers (** before the name of the variable), it is necessary to include the address of the variable (which is assigned by the compiler) at the end of the Mcode statement when the variable is being declared.  

The new variable declaration will be 

VD name NO_REFERENCE/ir value type FINAL/NOT_FINAL/GLOBAL/NOT_GLOBAL/STATIC/NOT_STATIC Loc Address

When declaring a variable the corresponding the MCode instruction needs to be omplemented with its name, value, type and the modifier. Instruction reference (ir) is given if the variable has an initializer otherwise a NO_REFERENCE value is written. The modifier can be Static, Not static, global, not global, Final and Not Final. 

The code above will be transferred into the following MCode. 

Any new or different instructions will be described below the MCode. 


VD	ptr	0	?	int_*	0	location		address
VD	x	1	3	int	0	location		address
Begin	A	2	location
	To	3
	QN	3	ptr	address??	int_*	location		address
	Begin 	AO	4	location
		Right	4
		QN	5	x	3	int	location		address
	AO	3	5	address		int_*	location
A	2	3	4	value(address)	int_*	location


int_* is a new type of variable for the MCode, it represents the pointer variable of type int. Another pointer variable is int_*_*, this represents a pointer to a pointer. 




QN ir name value type loc address

Qualified names are all the local variables. MCode instruction contains the reference (ir) of the instruction and the name value and type of the qualified name. If the variable is not initialized value will be UNKNOWN. The address of the variable is also included in this for the use of the C language. 

Address Of (AO) 

AO ir reference value type location

Address of is an instruction which will allow the address of a variable to be placed into a pointer variable. The MCode instruction contains the ir the reference the value, type and location.   



 
2.

*ptr = 10

Begin	A	6	location
	To	7	
	Begin	DR	7	location
		QN	8	ptr	value		int_*	location	address
	DR	7	8	address	3	int_*	location
	Literal	9	10	int	location
A	6	9	7	10	int	location

DR 

De-Reference ir reference address value type location 

The de-reference instruction will allow a pointer variable to be de-referenced i.e. the variable will go back along it’s path to the previous variable and find outs its value. The DR consists of the ir the reference the address, the value the type and the location. 

3.

X = (*ptr) +5

Begin	A	10	location
	To	11
	QN	11	x	10	int	location	address
	Begin	AE	12	location
		L	13
		Begin DR	13	location
			Right 14
			QN	14	ptr	0x0013(address)	int_*	location	 address
		DR	13	14	0x0013(address)	10	int	location
		R	15
		L	15	5	int	location
	AE	12	13	14	14	int	location
A	10	13	11	15	int	location

 
4.

Ptr2 = &ptr

VD	ptr2	1	?	int_*_*	0	location		address
Begin	A	2	location
	To	3	
	QN	3	ptr2	2	int_*_*		location		address
	Begin AO	4	location
		Right	5
		QN	5	ptr	address		int_*	location		address
	AO	4	5	address		int_*		location
A	2	4	3	address		int_*_*		location

5.

Function(20)

SMC	function	?	1	location		modifier
Begin	P	1	location
	Literal	1	20	int	location
P	1	20	int	address location
Parameters	i
MD Location

SMC name declaringClassName numArgs loc
The SMC instruction consists of the actual name of the method, its declaring class name and the number of arguments this method call consists of. It also consists of the modifier, whether it is global, final or static. 

SMCC

This instruction indicates the end of a call to a static method.

PARAMETERS parameterArray
The PARAMETERS instruction will provide the visualization engine a list of the types
of the parameters used in the method declaration.

P ir value type address loc
This instruction declares a new parameters in a method call. It requires a ir the value of the parameters the type the address and its location in the program. 


Method Declaration

MD ir loc
A method declaration instruction will indicate the location of the called method code and the beginning of its evaluation.
 
6.

Return (33);

Begin 	return	0	location
	Literal	2	33	int	location
Return	0(stack pop)	2	33	int	location
SMCC

Return
R callIr loc

This first return instruction is just used for the "void" return, those that does not return
anything. The callIr is the reference for the return value of the method and thus
connect the return command to the specific method.

R callIr valueIr value type loc

This second instruction is used when a value is returned. Thus, we need a reference to
the evaluation of the expression corresponding to the returned value (valueIr) and
the result of this expression, its value and type. 

In the instance above 

0 is callIr
2 is valueIr
33 is the value
int is the type
And location is the loc
 

7.

Funtion (int *i)

SMC 	function	?	1	location		modifier
Begin	P	1	location
	QN	1	ptr	0x1234		int_*	location		0x0100
	P	1	0x1234		int_*	0x0200
Parameters	i
MD	location

8.

Function (&x)

SMC 	function	?	1	location		modifier
Begin	P	1	location
Begin 	AO	1	location
		Right 2
		QN	2	x	??	location		address
	AO	1	2	0x1234		int_*	0x0300
Parameters	0x0300	
MD	location
 
9.

Struct MyStruct
{
	Char c
	Int i;
}
Typedef struct mystruct MY_NEW_TYPE;
Struct mystruct S1;
MY_NEW_TYPE s2 *ps;
Ps = &s1;

S1.c = ‘a’;

Class mystruct (modifier, FGS)
Field c char
Field i int
ENDCLASS

VD	S1	1	?	mystruct	(modifier)0	location		address (0x5678)
Begin	A	2	location
	To
	QN	4	S1	?	mystruct	location		address
	OFA 	3	4	c	?	char	modifier	location		address
	LIT	5	‘a’	char	location
A	2	5	3	‘a’	char	location




Object Field Access (OFA)
OFA ir objectReference name value type modifier loc address

This instruction accesses to the value of an object field, thus it references to the instruction
that evaluate the object (objectReference) (normally a Qualified Name. It contains the name, the type and the value of the accessed field, also the address of the object for use with C. 

3 = ir
4 object Reference
c name 
? value
char type
modifier is the modifier
location is the loc
address is the address 
10.

Struct MyStruct
{
	Char c
	Int i;
}

Typedef struct mystruct MY_NEW_TYPE;

Struct mystruct S1;
MY_NEW_TYPE S2;

S1.c = ‘a’;
S1.i = 47;

S2 = S1;

Class mystruct (moderator, FGS)
Field c char
Field i int
ENDCLASS

VD	S1	1	?	mystruct	(modifier)0	location		address (0x5678)
VD	S2	2	?	mystruct	(modifier)0	location		address (0x5678)
Begin	A	3	location
	To
	QN	4	S1	?	mystruct	location		address
	OFA 	5	4	c	?	char	modifier	location		address
	LIT	6	‘a’	char	location
Assign	2	7	3	‘a’	char	location
Begin	A	8	location
	To	9
	QN	9	S1	?	mystruct	location		address
	OFA 	10	9	i	?	int	modifier	location		address
	LIT	11	47	int	location
A	2	11	8	47	int	location
Begin	A	12	location
	To	13
	QN	13	S2	?	mystruct	location	address
	QN	14	S1	?	mystruct	location	address
A	3	14	13	12	mystruct	location

 

Int x = 15;	//global variable

VD 	x	1	3	int	2 (modifier)	location		address

 
Reference

Value	Name
1	LEFT
2	RIGHT
3	BEGIN
4	TO
5	A
6	AE
7	SE
8	ME
9	DE
10	RE
11	PLUS
12	MINUS
13	PIE
14	PRIE
15	PDE
16	PRDE
17	AND
18	OR
19	EE
20	NE
21	GT
22	LE
23	LQE
24	GQT
25	NO
26	VD
27	QN
28	L
29	SMC
30	P
31	PARAMETERS
32	R
33	IFT
34	IFTE
35	SCOPE
36	END
37	MD
38	SMCC
39	BR
40	WHI
41	FOR
42	CONT
43	DO
44	OUTPUT
45	COMP
46	BITOR
47	BITXOR
48	BITAND
49	LSHIFT
50	RSHIFT
51	URSHIFT
52	XOR
53	ERROR
54	INPUT
55	INPUTTED
56	AA
57	AAC
58	CLASS
59	END_CLASS
60	CONSTRUCTOR
61	METHOD
62	FIELD
63	SA
64	SAC
65	OFA
66	OMC
67	OMCC
68	SWIBF
69	SWITCHB
70	SWITCH
71	AL
72	CONSCN
73	CAST
74	SFA
75	AIBEGIN
76	AIE
77	AI
